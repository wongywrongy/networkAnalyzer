<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Local Network Monitor</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #ffffff; color: #111; height: 100vh; display: flex; flex-direction: column; }
    header { background: #1f6feb; color: #fff; padding: 6px 10px; display: flex; justify-content: space-between; align-items: center; }
    header h1 { margin: 0; font-size: 16px; }
    .shutdown-btn { background: #d93025; color: #fff; border: none; border-radius: 3px; padding: 4px 10px; cursor: pointer; font-size: 12px; }
    .shutdown-btn:hover { background: #c5221f; }
    .topbar { display: flex; gap: 8px; align-items: center; }
    .tabs { display: flex; gap: 4px; }
    .tab { padding: 6px 10px; border-radius: 4px; border: 1px solid #d0d7e2; background: #eef2f8; cursor: pointer; font-size: 12px; }
    .tab.active { background: #1f6feb; color: #fff; border-color: #1f6feb; }
    main { flex: 1; padding: 6px; display: grid; gap: 6px; grid-template-rows: 70% 30%; height: calc(100vh - 44px); }
    .pane { background: #fff; border: 0; border-radius: 4px; padding: 6px; overflow: hidden; display: flex; flex-direction: column; }
    .pane-header { display: flex; justify-content: space-between; align-items: center; gap: 6px; }
    h2 { margin: 0; font-size: 14px; }
    button { padding: 6px 10px; background: #1f6feb; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
    button:hover { background: #1a5fd9; }
    button:disabled { background: #9fb7e5; cursor: not-allowed; }
    input { padding: 4px 6px; width: 100%; border: 1px solid #d0d7e2; border-radius: 4px; font-size: 12px; }
    label { font-size: 12px; font-weight: 600; }
    .log-section { height: 100%; }
    .log { background: #0b172a; color: #d1e0ff; font-family: "SFMono-Regular", Menlo, Consolas, monospace; padding: 8px; flex: 1; overflow-y: auto; border-radius: 4px; font-size: 12px; }
    .log div { margin: 1px 0; }
    .interfaces-content { flex: 1; overflow-y: auto; gap: 6px; display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); grid-auto-rows: minmax(120px, auto); }
    .discover-inline { margin-top: 6px; }
    .discover-inline-list { margin-top: 4px; font-size: 11px; max-height: 120px; overflow-y: auto; border-top: 1px solid #eef1f6; padding-top: 4px; }
    .discover-inline-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; padding: 3px 0; }
    .interface-item { padding: 6px; border: 1px solid #eef1f6; border-radius: 4px; cursor: pointer; background: #f9fbff; }
    .interface-header { display: flex; justify-content: space-between; align-items: center; gap: 6px; }
    .interface-name { font-weight: 700; font-size: 12px; }
    .interface-details { font-size: 11px; color: #555; }
    .badge { display: inline-block; padding: 2px 4px; border-radius: 3px; background: #eef2ff; color: #2b3a67; font-size: 10px; margin-right: 4px; }
    .address-item { padding: 4px; margin: 2px 0; background: #f5f7fb; border-radius: 4px; border-left: 2px solid #d0d7e2; }
    .address-item.has-health { border-left-color: #1f6feb; }
    .address-text { font-family: monospace; font-size: 11px; }
    .address-health { font-size: 11px; margin-top: 2px; }
    .address-health.ok { color: #0f9d58; }
    .address-health.error { color: #d93025; }
    .address-health.info { color: #666; font-style: italic; }
    .address-health-details { margin-top: 6px; padding-top: 4px; border-top: 1px solid #eef1f6; display: none; }
    .interface-item.expanded .address-health-details { display: block; }
    .address-health-details table { width: 100%; font-size: 10px; }
    .address-health-details td { padding: 2px 4px; }
    .address-health-details td:first-child { font-weight: 600; color: #444; width: 40%; }
    .monitoring-status { font-size: 11px; color: #666; }
    .monitoring-status.active { color: #0f9d58; }
    .settings-panel { border-top: 1px solid #eef1f6; margin-top: 6px; padding-top: 6px; display: none; gap: 8px; flex-wrap: wrap; }
    .settings-panel.open { display: flex; }
    .control-group { display: flex; align-items: center; gap: 6px; }
    .control-group input { width: 70px; }
    .target-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 6px; width: 100%; max-height: 180px; overflow-y: auto; }
    .target-item { background: #f5f7fb; border: 1px solid #eef1f6; border-radius: 4px; padding: 6px; display: flex; align-items: center; gap: 6px; font-size: 11px; }
    .target-item .addr { font-family: monospace; }
    .internet-section { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .internet-result { font-size: 11px; color: #222; }
    .internet-block { padding: 6px; border: 1px solid #eef1f6; border-radius: 4px; background: #f5f7fb; margin-bottom: 6px; font-size: 11px; }
    .internet-block .title { font-weight: 700; margin-bottom: 4px; }
    .tabs-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .tab-content { flex: 1; overflow: hidden; display: none; }
    .tab-content.active { display: flex; flex-direction: column; }
    .events-list { flex: 1; overflow-y: auto; font-size: 11px; }
    .event-row { display: grid; grid-template-columns: 110px 1fr 100px 80px; gap: 6px; padding: 4px; border-bottom: 1px solid #eef1f6; }
    .pill { padding: 2px 4px; border-radius: 3px; font-size: 10px; }
    .pill.ok { background: #e0f4e8; color: #0f9d58; }
    .pill.err { background: #fde2e0; color: #d93025; }
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 999; }
    .overlay.open { display: flex; }
    .overlay-card { background: #fff; border-radius: 6px; padding: 12px; max-width: 900px; width: 90vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }
    .overlay-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .overlay-close { background: #d93025; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; }
    .overlay-section { margin-bottom: 8px; font-size: 12px; }
    .overlay-address { padding: 6px; border: 1px solid #eef1f6; border-radius: 4px; margin-bottom: 6px; background: #f8f9fb; }
    .overlay-address .addr { font-family: monospace; font-size: 12px; }
    .overlay-address .meta { font-size: 11px; color: #555; }
    .overlay-address .status { font-size: 11px; margin-top: 4px; }
    .overlay-address .status.ok { color: #0f9d58; }
    .overlay-address .status.err { color: #d93025; }
    .overlay-address .status.info { color: #666; font-style: italic; }
  </style>
</head>
<body>
  <header>
    <h1>Local Network Monitor</h1>
    <div class="topbar">
      <div class="tabs">
        <div class="tab active" id="tabBtn-interfaces" onclick="switchTab('interfaces')">Interfaces & Health</div>
        <div class="tab" id="tabBtn-events" onclick="switchTab('events')">Events</div>
      </div>
      <button class="shutdown-btn" onclick="shutdown()">Shutdown</button>
    </div>
  </header>
  <main>
    <div class="pane tabs-content">
      <div class="pane-header">
        <div class="monitoring-status" id="monitoringStatus">Stopped</div>
        <div style="display:flex; gap:6px; align-items:center;">
          <button id="toggleBtn" onclick="toggleMonitoring()">Start</button>
          <button onclick="toggleSettings()">Settings</button>
        </div>
      </div>

      <div id="tab-interfaces" class="tab-content active">
        <div id="settingsPanel" class="settings-panel">
          <div class="control-group">
            <label>Interface Poll (s)</label>
            <input id="pollInterval" type="number" value="5" min="1" />
          </div>
          <div class="control-group">
            <label>Health Interval (s)</label>
            <input id="healthInterval" type="number" value="10" min="1" />
          </div>
          <div style="width:100%;">
            <div style="font-weight:600; margin-bottom:4px;">Health Monitoring Targets</div>
            <div id="targetList" class="target-list"></div>
          </div>
          <div class="internet-section">
            <button onclick="runInternetTest()">Run Internet Test</button>
            <span id="internetResult" class="internet-result"></span>
          </div>
        </div>

        <div id="interfaces" class="interfaces-content"></div>
      </div>

      <div id="tab-events" class="tab-content">
        <div class="events-list" id="eventsList"></div>
      </div>
    </div>

    <div class="pane log-section">
      <div class="pane-header">
        <h2>Terminal Log</h2>
      </div>
      <div id="log" class="log"></div>
    </div>
  </main>

  <div id="overlay" class="overlay" onclick="closeOverlay(event)">
    <div class="overlay-card" onclick="event.stopPropagation();">
      <div class="overlay-header">
        <div id="overlayTitle" style="font-weight:700; font-size:14px;">Details</div>
        <button class="overlay-close" onclick="closeOverlay(event)">Close</button>
      </div>
      <div id="overlayBody"></div>
    </div>
  </div>

  <script>
    const logEl = document.getElementById('log');
    function log(msg, level='info') {
      const ts = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.textContent = `[${ts}] ${msg}`;
      if (level === 'error') line.style.color = '#f88';
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    let monitoring = false;
    let pollTimer = null;
    let healthCheckTimers = new Map();
    let currentInterfaces = new Map();
    let addressHealthChecks = new Map();
    let selectedTargets = new Set();
    let internetTimer = null;
    let lastInternetResult = null;
    let lastInternetTs = null;
    const events = [];
    const maxEvents = 300;

    function extractIP(addrString) {
      // Extract IP from CIDR notation like "192.168.1.1/24" or "fe80::1/64"
      const parts = addrString.split('/');
      return parts[0];
    }

    function getAddressType(ip) {
      if (!ip) return { pingable: false, type: 'Invalid' };
      if (ip.startsWith('127.') || ip.startsWith('::1')) return { pingable: false, type: 'Loopback' };
      if (ip.startsWith('169.254.')) return { pingable: false, type: 'APIPA (Link-local IPv4)' };
      if (ip.startsWith('fe80:')) return { pingable: false, type: 'IPv6 Link-local' };
      if (ip.startsWith('ff')) return { pingable: false, type: 'IPv6 Multicast' };
      if (ip.includes(':')) return { pingable: true, type: 'IPv6' };
      return { pingable: true, type: 'IPv4' };
    }

    function isPingableIP(ip) {
      return getAddressType(ip).pingable;
    }

    function switchTab(tabId) {
      ['interfaces', 'events'].forEach(id => {
        document.getElementById(`tab-${id}`).classList.toggle('active', id === tabId);
        document.getElementById(`tabBtn-${id}`).classList.toggle('active', id === tabId);
      });
    }

    function addEvent(evt) {
      evt.ts = evt.ts || Date.now();
      events.unshift(evt);
      if (events.length > maxEvents) events.pop();
      renderEvents();
    }

    function renderEvents() {
      const list = document.getElementById('eventsList');
      if (!list) return;
      list.innerHTML = '';
      events.forEach(e => {
        const row = document.createElement('div');
        row.className = 'event-row';
        const time = new Date(e.ts).toLocaleTimeString();
        const statusClass = e.status === 'ok' ? 'ok' : e.status === 'err' ? 'err' : '';
        row.innerHTML = `
          <div>${time}</div>
          <div>${e.msg || ''}</div>
          <div><span class="pill ${statusClass}">${e.type || ''}</span></div>
          <div>${e.meta || ''}</div>
        `;
        list.appendChild(row);
      });
    }

    async function pingOnce(target) {
      const res = await fetch(`/api/ping?target=${encodeURIComponent(target)}`);
      if (!res.ok) throw new Error(await res.text());
      return res.json();
    }

    async function runInternetTest() {
      const el = document.getElementById('internetResult');
      if (el) el.textContent = 'Running...';
      try {
        const res = await fetch('/api/internet');
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        lastInternetResult = data;
        lastInternetTs = Date.now();
        const lines = [];
        lines.push(`DNS: ${data.resolveTimeMs} ms (${Object.entries(data.resolvedHosts || {}).map(([h, ok]) => ok ? h+' ok' : h+' fail').join(', ')})`);
        const ct = data.connectTimes || {};
        Object.keys(ct).forEach(k => {
          const v = ct[k];
          lines.push(`TCP ${k}: ${v >= 0 ? v + ' ms' : 'fail'}`);
        });
        lines.push(`HTTP: status ${data.httpStatus || 0} in ${data.httpDurationMs || -1} ms`);
        const msg = lines.join(' | ');
        if (el) el.textContent = msg;
        log(`Internet test: ${msg}`);
        addEvent({ type: 'internet', status: 'ok', msg, meta: '' });
        renderInterfaces();
      } catch (err) {
        if (el) el.textContent = `Error: ${err.message}`;
        log(`Internet test failed: ${err.message}`, 'error');
        addEvent({ type: 'internet', status: 'err', msg: `Internet test failed: ${err.message}`, meta: '' });
        renderInterfaces();
      }
    }

    function formatDuration(dur) {
      if (!dur || dur === 0) return null; // Return null to indicate no valid duration
      if (typeof dur === 'string') return dur;
      const ms = dur / 1000000;
      if (ms < 1) return '<1ms';
      return `${ms.toFixed(1)}ms`;
    }

    async function loadInterfaces() {
      try {
        const res = await fetch('/api/interfaces');
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        
        // Check if interfaces changed
        const currentKeys = new Set(data.map(i => i.Name));
        const previousKeys = new Set(currentInterfaces.keys());
        const added = [...currentKeys].filter(k => !previousKeys.has(k));
        const removed = [...previousKeys].filter(k => !currentKeys.has(k));
        
        if (added.length > 0 || removed.length > 0) {
          log(`Interface change detected: ${added.length} added, ${removed.length} removed`);
        }

        // Update current interfaces map
        currentInterfaces.clear();
        data.forEach(iface => {
          currentInterfaces.set(iface.Name, iface);
        });

        // Ensure selectedTargets contains all pingable IPs by default
        data.forEach(iface => {
          (iface.Addresses || []).forEach(addrString => {
            const ip = extractIP(addrString);
            if (!isPingableIP(ip)) return;
            const key = `${iface.Name}:${ip}`;
            if (!selectedTargets.has(key)) {
              selectedTargets.add(key);
            }
          });
        });

        renderInterfaces();
        renderTargetList();
        
        // Start health checks for new addresses if monitoring is active
        if (monitoring) {
          startHealthChecksForInterfaces(data);
        }
      } catch (err) {
        log(`Interface fetch failed: ${err.message}`, 'error');
      }
    }

    function startHealthChecksForInterfaces(interfaces) {
      const healthInterval = parseInt(document.getElementById('healthInterval').value, 10) * 1000;
      
      interfaces.forEach(iface => {
        (iface.Addresses || []).forEach(addrString => {
          const ip = extractIP(addrString);
          if (!isPingableIP(ip)) return;
          const key = `${iface.Name}:${ip}`;
          if (!selectedTargets.has(key)) return; // only monitor selected targets
          
          if (!addressHealthChecks.has(key)) {
            addressHealthChecks.set(key, {
              interface: iface.Name,
              address: addrString,
              ip: ip,
              lastResult: null,
              timer: null
            });
            // Start health check immediately
            runAddressHealthCheck(key);
          }
        });
      });

      // Clean up health checks for addresses that no longer exist
      const currentAddressKeys = new Set();
      interfaces.forEach(iface => {
        (iface.Addresses || []).forEach(addrString => {
          const ip = extractIP(addrString);
          if (isPingableIP(ip)) {
            currentAddressKeys.add(`${iface.Name}:${ip}`);
          }
        });
      });

      addressHealthChecks.forEach((check, key) => {
        if (!currentAddressKeys.has(key)) {
          if (check.timer) {
            clearTimeout(check.timer);
          }
          addressHealthChecks.delete(key);
        }
      });
    }

    async function runAddressHealthCheck(key) {
      if (!monitoring) return;
      
      const check = addressHealthChecks.get(key);
      if (!check) return;

      try {
        const result = await pingOnce(check.ip);
        result.timestamp = Date.now();
        check.lastResult = result;
        renderInterfaces();
        
        if (result.ErrorMessage) {
          log(`Health check ${check.ip} (${check.interface}) failed: ${result.ErrorMessage}`, 'error');
          addEvent({ type: 'health', status: 'err', msg: `Ping ${check.ip} failed`, meta: check.interface });
        } else {
          const avgRTT = formatDuration(result.AvgRTT) || (result.PacketsRecv > 0 ? '<1ms' : null);
          if (result.PacketsRecv === 0) {
            log(`Health check ${check.ip} (${check.interface}): No response (${result.PacketsSent} sent, ${result.PacketsRecv} received)`);
            addEvent({ type: 'health', status: 'err', msg: `Ping ${check.ip} no response`, meta: check.interface });
          } else {
            log(`Health check ${check.ip} (${check.interface}): avg=${avgRTT} loss=${result.PacketLoss.toFixed(1)}%`);
            addEvent({ type: 'health', status: 'ok', msg: `Ping ${check.ip} avg ${avgRTT} loss=${result.PacketLoss.toFixed(1)}%`, meta: check.interface });
          }
        }
      } catch (err) {
        log(`Health check error for ${check.ip}: ${err.message}`, 'error');
        addEvent({ type: 'health', status: 'err', msg: `Ping ${check.ip} error: ${err.message}`, meta: check.interface });
      }

      if (monitoring) {
        const healthInterval = parseInt(document.getElementById('healthInterval').value, 10) * 1000;
        check.timer = setTimeout(() => runAddressHealthCheck(key), healthInterval);
      }
    }

    function renderInterfaces() {
      const container = document.getElementById('interfaces');
      container.innerHTML = '';

      if (lastInternetResult) {
        const block = document.createElement('div');
        block.className = 'internet-block';
        const ts = lastInternetTs ? new Date(lastInternetTs).toLocaleTimeString() : '';
        const lines = [];
        const dnsPart = `DNS ${lastInternetResult.resolveTimeMs ?? '-'} ms`;
        const resolved = lastInternetResult.resolvedHosts || {};
        const resolvedList = Object.entries(resolved).map(([h, ok]) => `${h}:${ok ? 'ok' : 'fail'}`).join(', ');
        lines.push(`${dnsPart} [${resolvedList}]`);
        const ct = lastInternetResult.connectTimes || {};
        Object.keys(ct).forEach(k => {
          const v = ct[k];
          lines.push(`TCP ${k}: ${v >= 0 ? v + ' ms' : 'fail'}`);
        });
        lines.push(`HTTP ${lastInternetResult.httpStatus || 0} in ${lastInternetResult.httpDurationMs ?? '-'} ms`);
        block.innerHTML = `
          <div class="title">Internet (device)</div>
          <div>${lines.join(' | ')}</div>
          <div style="color:#555;">${ts}</div>
        `;
        container.appendChild(block);
      }
      
      currentInterfaces.forEach((iface, name) => {
        const div = document.createElement('div');
        div.className = 'interface-item';
        div.dataset.interface = name;
        
        const flags = (iface.Flags || []).join(', ');
        
        div.innerHTML = `
          <div class="interface-header">
            <div>
              <div class="interface-name">${iface.Name}</div>
              <div class="interface-details">MTU: ${iface.MTU} | MAC: ${iface.MAC}</div>
              <div class="badge">${flags}</div>
            </div>
          </div>
          <div class="interface-addresses"></div>
        `;
        
        const addressesContainer = div.querySelector('.interface-addresses');
        (iface.Addresses || []).forEach(addrString => {
          const ip = extractIP(addrString);
          const key = `${name}:${ip}`;
          const addrType = getAddressType(ip);
          const healthCheck = addressHealthChecks.get(key);
          const hasHealth = healthCheck && healthCheck.lastResult;
          const isSelected = selectedTargets.has(key);
          
          const addrDiv = document.createElement('div');
          addrDiv.className = `address-item ${hasHealth ? 'has-health' : ''}`;
          
          const result = healthCheck ? healthCheck.lastResult : null;
          let statusText = '';
          let status = '';
          
          if (!addrType.pingable) {
            statusText = addrType.type;
            status = 'info';
          } else if (result) {
            if (result.ErrorMessage) {
              status = 'error';
              statusText = `Error: ${result.ErrorMessage}`;
            } else {
              const avgRTT = formatDuration(result.AvgRTT) || (result.PacketsRecv > 0 ? '<1ms' : null);
              if (result.PacketsRecv === 0) {
                status = 'error';
                statusText = `No response (${result.PacketsSent} sent, ${result.PacketsRecv} received)`;
              } else {
                status = 'ok';
                statusText = `Avg: ${avgRTT} | Loss: ${result.PacketLoss.toFixed(1)}%`;
              }
            }
          } else if (monitoring && isSelected) {
            statusText = 'Checking...';
            status = 'info';
          } else if (addrType.type) {
            statusText = addrType.type;
            status = 'info';
          }
          
          addrDiv.innerHTML = `
            <div class="address-text">${addrString}</div>
            ${statusText ? `<div class="address-health ${status}">${statusText}</div>` : ''}
          `;
          
          addressesContainer.appendChild(addrDiv);
        });
        
        div.onclick = () => openOverlayForInterface(iface);
        
        container.appendChild(div);
      });
    }

    function renderTargetList() {
      const container = document.getElementById('targetList');
      if (!container) return;
      container.innerHTML = '';

      const entries = [];
      currentInterfaces.forEach((iface, name) => {
        (iface.Addresses || []).forEach(addrString => {
          const ip = extractIP(addrString);
          if (!isPingableIP(ip)) return;
          entries.push({ key: `${name}:${ip}`, iface: name, addr: addrString });
        });
      });

      entries.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'target-item';
        const checked = selectedTargets.has(entry.key);
        item.innerHTML = `
          <input type="checkbox" ${checked ? 'checked' : ''} data-key="${entry.key}" />
          <label>
            <span class="addr">${entry.addr}</span>
            <span style="color:#666;">${entry.iface}</span>
          </label>
        `;
        const checkbox = item.querySelector('input');
        checkbox.onchange = (e) => {
          if (e.target.checked) {
            selectedTargets.add(entry.key);
            // if monitoring, start this target
            const parts = entry.key.split(':');
            if (monitoring && parts.length === 2) {
              const ifaceName = parts[0];
              const ip = parts[1];
              const iface = currentInterfaces.get(ifaceName);
              if (iface) {
                startHealthChecksForInterfaces([iface]);
              }
            }
          } else {
            selectedTargets.delete(entry.key);
            // stop health check if running
            const existing = addressHealthChecks.get(entry.key);
            if (existing && existing.timer) clearTimeout(existing.timer);
            addressHealthChecks.delete(entry.key);
            renderInterfaces();
          }
        };
        container.appendChild(item);
      });
    }

    function renderHealthDetails(result) {
      if (result.ErrorMessage) {
        return `<div style="color: #d93025; font-size: 11px;">Error: ${result.ErrorMessage}</div>`;
      }
      const minRTT = formatDuration(result.MinRTT) || 'N/A';
      const maxRTT = formatDuration(result.MaxRTT) || 'N/A';
      const avgRTT = formatDuration(result.AvgRTT) || 'N/A';
      const stdDevRTT = formatDuration(result.StdDevRTT) || 'N/A';
      const duration = formatDuration(result.Duration) || 'N/A';
      return `
        <table>
          <tr><td>Packets Sent:</td><td>${result.PacketsSent}</td></tr>
          <tr><td>Packets Received:</td><td>${result.PacketsRecv}</td></tr>
          <tr><td>Packet Loss:</td><td>${result.PacketLoss.toFixed(1)}%</td></tr>
          <tr><td>Min RTT:</td><td>${minRTT}</td></tr>
          <tr><td>Max RTT:</td><td>${maxRTT}</td></tr>
          <tr><td>Avg RTT:</td><td>${avgRTT}</td></tr>
          <tr><td>StdDev RTT:</td><td>${stdDevRTT}</td></tr>
          <tr><td>Duration:</td><td>${duration}</td></tr>
        </table>
      `;
    }

    function openOverlayForInterface(iface) {
      const overlay = document.getElementById('overlay');
      const body = document.getElementById('overlayBody');
      const title = document.getElementById('overlayTitle');
      title.textContent = `Interface: ${iface.Name}`;

      let html = '';
      html += `<div class="overlay-section"><strong>MTU:</strong> ${iface.MTU} &nbsp; <strong>MAC:</strong> ${iface.MAC || '-'}</div>`;
      html += `<div class="overlay-section"><strong>Flags:</strong> ${(iface.Flags || []).join(', ')}</div>`;

      html += `<div class="overlay-section"><strong>Addresses</strong></div>`;
      (iface.Addresses || []).forEach(addrString => {
        const ip = extractIP(addrString);
        const addrType = getAddressType(ip);
        const key = `${iface.Name}:${ip}`;
        const healthCheck = addressHealthChecks.get(key);
        const result = healthCheck ? healthCheck.lastResult : null;
        const isSelected = selectedTargets.has(key);
        
        let status = '';
        let statusText = '';
        
        if (!addrType.pingable) {
          status = 'info';
          statusText = addrType.type;
        } else if (result) {
          if (result.ErrorMessage) {
            status = 'err';
            statusText = `Error: ${result.ErrorMessage}`;
          } else {
            const avgRTT = formatDuration(result.AvgRTT) || (result.PacketsRecv > 0 ? '<1ms' : null);
            if (result.PacketsRecv === 0) {
              status = 'err';
              statusText = `No response (${result.PacketsSent} sent, ${result.PacketsRecv} received)`;
            } else {
              status = 'ok';
              statusText = `Avg ${avgRTT} | Loss ${result.PacketLoss.toFixed(1)}%`;
            }
          }
        } else if (monitoring && isSelected) {
          status = 'info';
          statusText = 'Checking...';
        } else {
          status = 'info';
          statusText = addrType.type;
        }
        
        html += `
          <div class="overlay-address">
            <div class="addr">${addrString}</div>
            <div class="meta">Type: ${addrType.type}${addrType.pingable ? ` | Selected: ${isSelected ? 'Yes' : 'No'}` : ''}</div>
            <div class="status ${status}">${statusText}</div>
            ${result ? `<div class="address-health-details">${renderHealthDetails(result)}</div>` : ''}
          </div>
        `;
      });

      body.innerHTML = html;
      overlay.classList.add('open');
    }

    function closeOverlay(e) {
      const overlay = document.getElementById('overlay');
      overlay.classList.remove('open');
    }

    function toggleMonitoring() {
      monitoring = !monitoring;
      const btn = document.getElementById('toggleBtn');
      const status = document.getElementById('monitoringStatus');
      
      if (monitoring) {
        btn.textContent = 'Stop Monitoring';
        status.textContent = 'Monitoring Active';
        status.classList.add('active');
        
        const pollInterval = parseInt(document.getElementById('pollInterval').value, 10) * 1000;
        loadInterfaces(); // Initial load
        pollTimer = setInterval(loadInterfaces, pollInterval);
        log(`Started monitoring (poll: ${pollInterval/1000}s, health: ${document.getElementById('healthInterval').value}s)`);
        startInternetMonitoring();
      } else {
        btn.textContent = 'Start Monitoring';
        status.textContent = 'Stopped';
        status.classList.remove('active');
        
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
        
        addressHealthChecks.forEach(check => {
          if (check.timer) {
            clearTimeout(check.timer);
            check.timer = null;
          }
        });
        addressHealthChecks.clear();
        stopInternetMonitoring();
        log('Stopped monitoring');
      }
    }

    function startInternetMonitoring() {
      stopInternetMonitoring();
      const run = () => runInternetTest();
      run();
      const healthInterval = parseInt(document.getElementById('healthInterval').value, 10) * 1000;
      internetTimer = setInterval(run, healthInterval);
    }

    function stopInternetMonitoring() {
      if (internetTimer) {
        clearInterval(internetTimer);
        internetTimer = null;
      }
    }

    async function runDiscovery() {
      const listEl = document.getElementById('discoverList');
      const inlineEl = document.getElementById('discoverInlineList');
      if (listEl) listEl.innerHTML = 'Discovering...';
      if (inlineEl) inlineEl.innerHTML = 'Discovering...';
      try {
        const res = await fetch('/api/discover');
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        if (listEl) {
          listEl.innerHTML = '';
          if (!data.length) {
            listEl.textContent = 'No entries found.';
          } else {
            data.forEach(row => {
              const div = document.createElement('div');
              div.className = 'discover-row';
              div.innerHTML = `<div>${row.ip || ''}</div><div>${row.mac || ''}</div><div>${row.type || ''}</div>`;
              listEl.appendChild(div);
            });
          }
        }
        if (inlineEl) {
          inlineEl.innerHTML = '';
          if (!data.length) {
            inlineEl.textContent = 'No entries found.';
          } else {
            data.forEach(row => {
              const div = document.createElement('div');
              div.className = 'discover-inline-row';
              div.innerHTML = `<div>${row.ip || ''}</div><div>${row.mac || ''}</div><div>${row.type || ''}</div>`;
              inlineEl.appendChild(div);
            });
          }
        }
        log(`Discovery completed (${data.length} entries)`);
        addEvent({ type: 'discover', status: 'ok', msg: `ARP entries: ${data.length}`, meta: '' });
      } catch (err) {
        if (listEl) listEl.textContent = `Error: ${err.message}`;
        if (inlineEl) inlineEl.textContent = `Error: ${err.message}`;
        log(`Discovery error: ${err.message}`, 'error');
        addEvent({ type: 'discover', status: 'err', msg: `Discovery error: ${err.message}`, meta: '' });
      }
    }

    async function shutdown() {
      if (!confirm('Are you sure you want to shutdown the server? This will close the application.')) {
        return;
      }
      try {
        const res = await fetch('/api/shutdown');
        if (!res.ok) throw new Error(await res.text());
        log('Shutdown request sent. Server will close shortly...', 'info');
        setTimeout(() => {
          alert('Server is shutting down. The page will become unavailable.');
        }, 500);
      } catch (err) {
        log(`Shutdown error: ${err.message}`, 'error');
      }
    }

    function toggleSettings() {
      const panel = document.getElementById('settingsPanel');
      panel.classList.toggle('open');
    }

    // Initial load
    loadInterfaces();
  </script>
</body>
</html>
